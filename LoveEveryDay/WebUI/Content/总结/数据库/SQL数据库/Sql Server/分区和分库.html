<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <link href="/WebUI/Resource/Javascript/plugins/syntaxhighlighter/highlightstyle.css" rel="stylesheet" />
    <link href="/WebUI/Resource/Css/DetailSite.css" rel="stylesheet" />
    <title></title>
</head>
<body>
    <div class="container">
        <p>谈论数据库架构和数据库优化的时候，我们经常会听到“分库分表”、“分片”这样的关键词。让人感到高兴的是，这些朋友所服务的公司业务量正在（或者即将面临）高速增长，技术方面也面临着一些挑战。</p>
        <h3>垂直分</h3>
        <h4>垂直分表</h4>
        <p>垂直分表在日常开发和设计中比较常见，通俗的说法叫做“大表拆小表”，拆分是基于关系型数据库中的“列”（字段）进行的。通常情况，某个表中的字段比较多，可以新建立一张“扩展表”，将不经常使用或者长度较大的字段拆分出去放到“扩展表”中，如下图所示：</p>
        <img class="little" src="http://static.open-open.com/lib/uploadImg/20160914/20160914103813_951.png" />
        <h5>小结</h5>
        <p>在字段很多的情况下，拆分开确实更便于开发和维护,。某种意义上也能避免“跨页”的问题（MySQL、MSSQL底层都是通过“数据页”来存储的，“跨页”问题可能会造成额外的性能开销</p>
        <p>拆分字段的操作建议在数据库设计阶段就做好。如果是在发展过程中拆分，则需要改写以前的查询语句，会额外带来一定的成本和风险，建议谨慎。</p>
        <h4>垂直分库</h4>
        <p>基本的思路就是按照业务模块来划分出不同的数据库，而不是像早期一样将所有的数据表都放到同一个数据库中。如下图：</p>
        <img class="little" src="http://static.open-open.com/lib/uploadImg/20160914/20160914103813_645.png"/>
        <h5>小结</h5>
        <p>系统层面的“服务化”拆分操作，能够解决业务系统层面的耦合和性能瓶颈，有利于系统的扩展维护。而数据库层面的拆分，道理也是相通的。与服务的“治理”和“降级”机制类似，我们也能对不同业务类型的数据进行“分级”管理、维护、监控、扩展等。</p>
        <h3>水平分</h3>
        <h4>水平分表</h4>
        <p>水平分表也称为横向分表，比较容易理解，就是将表中不同的数据行按照一定规律分布到不同的数据库表中（这些表保存在同一个数据库中），这样来降低单表数据量，优化查询性能。最常见的方式就是通过主键或者时间等字段进行Hash和取模后拆分。如下图所示：</p>
        <img class="little" src="http://static.open-open.com/lib/uploadImg/20160914/20160914103813_168.png" />
        <h5>小结</h5>
        <h5>水平分表，能够降低单表的数据量，一定程度上可以缓解查询性能瓶颈。但本质上这些表还保存在同一个库中，所以库级别还是会有IO瓶颈。所以，一般不建议采用这种做法。</h5>
        <h4>水平分库分表</h4>
        <P>水平分库分表与上面讲到的水平分表的思想相同，唯一不同的就是将这些拆分出来的表保存在不同的数据中。这也是很多大型互联网公司所选择的做法。如下图：</P>
        <img class="little" src="http://static.open-open.com/lib/uploadImg/20160914/20160914103813_760.jpg" />
        <P>某种意义上来讲，有些系统中使用的“冷热数据分离”（将一些使用较少的历史数据迁移到其他的数据库中。而在业务功能上，通常默认只提供热点数据的查询），也是类似的实践。在高并发和海量数据的场景下，分库分表能够有效缓解单机和单库的性能瓶颈和压力，突破IO、连接数、硬件资源的瓶颈。当然，投入的硬件成本也会更高。同时，这也会带来一些复杂的技术问题和挑战（例如：跨分片的复杂查询，跨分片事务等）</P>
        <em>跨库join的问题</em>
        
        <ul>
            <li>
                分库分表的难点
                <p>在拆分之前，系统中很多列表和详情页所需的数据是可以通过sql join来完成的。而拆分后，数据库可能是分布式在不同实例和不同的主机上，join将变得非常麻烦。而且基于架构规范，性能，安全性等方面考虑，一般是禁止跨库join的。那该怎么办呢？首先要考虑下垂直分库的设计问题，如果可以调整，那就优先调整。如果无法调整的情况，下面笔者将结合以往的实际经验，总结几种常见的解决思路，并分析其适用场景</p>
                <ul>
                    <li>全局表<p>所谓全局表，就是有可能系统中所有模块都可能会依赖到的一些表。比较类似我们理解的“数据字典”。为了避免跨库join查询，我们可以将这类表在其他每个数据库中均保存一份。同时，这类数据通常也很少发生修改（甚至几乎不会），所以也不用太担心“一致性”问题。</p></li>
                    <li>字段冗余<p>这是一种典型的反范式设计，在互联网行业中比较常见，通常是为了性能来避免join查询。字段冗余能带来便利，是一种“空间换时间”的体现。但其适用场景也比较有限，比较适合依赖字段较少的情况。最复杂的还是数据一致性问题，这点很难保证，可以借助数据库中的触发器或者在业务代码层面去保证。当然，也需要结合实际业务场景来看一致性的要求</p></li>
                    <li>数据同步<P>定时A库中的tab_a表和B库中tbl_b有关联，可以定时将指定的表做同步。当然，同步本来会对数据库带来一定的影响，需要性能影响和数据时效性中取得一个平衡。这样来避免复杂的跨库查询</P></li>
                    <li>系统层组装<p>简单字段组装的情况下，我们只需要先获取“主表”数据，然后再根据关联关系，调用其他模块的组件或服务来获取依赖的其他字段（如例中依赖的用户信息），最后将数据进行组装。通常，我们都会通过缓存来避免频繁RPC(RPC是指远程过程调用)通信和数据库查询的开销。</p></li>
                </ul>
            </li>
        </ul>
        <p>按业务拆分数据库之后，不可避免的就是“分布式事务”的问题。以往在代码中通过spring注解简单配置就能实现事务的，现在则需要花很大的成本去保证一致性。</p>
        <h3>实践建议</h3>
        <ul>
            <li>根据系统架构和公司实际情况来，如果你们的系统还是个简单的单体应用，并且没有什么访问量和数据量，那就别着急折腾“垂直分库”了，否则没有任何收益，也很难有好结果。“过度设计”和“过早优化”都是不恰当的</li>
            <li>一般是参考系统的业务模块拆分来进行数据库的拆分。比如“用户服务”，对应的可能就是“用户数据库”。但是也不一定严格一一对应。有些情况下，数据库拆分的粒度可能会比系统拆分的粒度更粗。有些系统中的某些表原本应该放A库中的，却放在了B库中。有些库和表原本是可以合并的，却单独保存着。还有些表，看起来放在A库中也OK，放在B库中也合理。如何设计和权衡，这个就看实际情况了，没有什么黄金法则和标准答案。</li>
            <li>其实互联网的业务系统中，本来就应该尽量避免join的，如果有多个join的，要么是设计不合理，要么是技术选型有误。在传统BI时代都是通过OLAP数据仓库去实现的,现在则更多是借助离线分析、流式计算等手段实现,而不该向上面描述的那样直接在业务库中执行大量join和统计</li>
        </ul>
        <h5>OLTP与OLAP的介绍</h5>
        <p>数据处理大致可以分成两大类：联机事务处理OLTP（on-line transaction processing）、联机分析处理OLAP（On-Line Analytical Processing）。OLTP是传统的关系型数据库的主要应用，主要是基本的、日常的事务处理，例如银行交易。OLAP是数据仓库系统的主要应用，支持复杂的分析操作，侧重决策支持，并且提供直观易懂的查询结果。</p>
        <P>OLTP 系统强调数据库内存效率，强调内存各种指标的命令率，强调绑定变量，强调并发操作；
OLAP 系统则强调数据分析，强调SQL执行市场，强调磁盘I/O，强调分区等。 </P>
        <img class="little" src="http://img.my.csdn.net/uploads/201212/08/1354896501_9646.jpg" />
    </div>
</body>
</html>
<script src="//libs.baidu.com/jquery/2.1.4/jquery.min.js"></script>
<script>window.jQuery || document.write('<script src="/WebUI/Resource/Javascript/jquery.min.js"><\/script>');</script>
<script type="text/javascript" src="http://cdn.bootcss.com/highlight.js/8.0/highlight.min.js"></script>
<script type="text/javascript">hljs.initHighlightingOnLoad();</script>

<script type="text/javascript">
    $(function () {


    })
</script>

