using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DesignMethod.单例模式
{
    #region  解析
    /* 通过单例模式可以保证系统中一个类只有一个实例
     * 单例模式设计的核心是为了控制用户使用new对一个类的实例构造器的任意调用。
     * 显然单例模式的要点有三个；一是某个类只能有一个实例；二是它必须自行创建这个实例；三是它必须自行向整个系统提供这个实例。
     * 
     * 从具体实现角度来说，就是以下三点：
     * 1.是单例模式的类只提供私有的构造函数。  
     *    这样就限制了在其他类中创建该类的对象的情况。即使该类不是密封类，
     *    继承该类的子类中也无法创建父类对象和子类对象，因为在创建的时候需要
     *    调用父类的构造方法，而私有的父类构造方法是子类调用不到的。
     * 2.是类定义中含有一个该类的静态私有对象，即静态方法或属性或只读字段返回该对象类型。
     *   既然在其他类中无法创建新的实例，唯一的实例只能在本类的定义中提供了。
     *   这就需要一个静态的成员来保证在其他类中能获得该实例，否则就瞎菜了
     * 
     * 3.是该类提供了一个静态的公有的函数用于创建或获取它本身的静态私有对象。
     * 
     * http://www.cnblogs.com/wwkk/p/4712234.html
     * 应用场景：
     * 任务管理器    回收站   网站的计数器  操作系统的文件系统  Web应用的配置对象的读取 共享文件 数据库连接池  多线程的线程池
     * 
     * 
     * 优点：
     * 1.实例控制：单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例。
     * 2.灵活性：因为类控制了实例化过程，所以类可以灵活更改实例化过程。
     * 
     * 缺点：
     * 1.开销：虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题。
     * 2.可能的开发混淆：使用单例对象（尤其在类库中定义的对象）时，开发人员必须记住自己不能使用new关键字实例化对象。
     * 因为可能无法访问库源代码，因此应用程序开发人员可能会意外发现自己无法直接实例化此类。
     * 3.对象生存期:不能解决删除单个对象的问题。在提供内存管理的语言中（例如基于.NET Framework的语言），
     * 只有单例类能够导致实例被取消分配，因为它包含对该实例的私有引用。
     * 在某些语言中（如 C++），其他类可以删除对象实例，但这样会导致单例类中出现悬浮引用。
     * */

    #endregion


    public class 测试类
    {
        public static void 运行()
        {
            //唯一的实例
            任务 task = 任务.创建任务();
            task.开启();
        }
    }


    //----------------------------------------------------------------------------------------

    //任务管理器    通过 辅助变量+Double_Lock+Volatile
    public class 任务
    {
        //禁止构造
        private 任务(){}

        //定义一个标示确保线程同步 
        //private static readonly object 这个任务存在 = new object();
        // 私有静态变量+volatile（保证编译顺序）
        private static volatile object 这个任务存在 = new object();

        //定义私有静态实例  辅助变量
        private static 任务 唯一的本任务;

        //定义全局访问点
        public static 任务 创建任务()
        {
            //第一个线程运行，此时会对locker对象“加锁”
            //第二个线程运行，首先检测locker对象为“加锁”状态，该线程就会挂起等待第一个线程解锁
            //lock语句运行完后，会对该对象“解锁”
            //双重锁定只需要一句话判断就可以了
            if (这个任务存在 == null)
            {
                lock (这个任务存在)
                {
                    if (唯一的本任务 == null)
                    {
                        唯一的本任务 = new 任务();
                    }
                }
            }
            return 唯一的本任务;
        }


        public void 开启()
        {
            Console.Write("单例模式启动");
            Console.Read();
        }
    }
}
