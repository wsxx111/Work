using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;

namespace DesignMethod.工厂方法
{
   #region  解析
    /* 为创建一组相关或相互依赖的对象提供一个接口，而且无需指定他们的具体类。----抽象工厂
     *
     * 工厂方法是针对每一种产品提供一个工厂类。通过不同的工厂实例来创建不同的产品实例。在同一等级结构中，支持增加任意产品。
     * 抽象工厂是应对产品族概念的。比如说，每个汽车公司可能要同时生产轿车，货车，客车，那么每一个工厂都要有创建轿车，货车和客车的方法。
     * 应对产品族概念而生，增加新的产品线很容易，但是无法增加新的产品。
     * 工厂模式中，重要的是工厂类，而不是产品类。产品类可以是多种形式，多层继承或者是单个类都是可以的。
     * 但要明确的，工厂模式的接口只会返回一种类型的实例，这是在设计产品类的时候需要注意的，最好是有父类或者共同实现的接口。
     * 使用工厂模式，返回的实例一定是工厂创建的，而不是从其他对象中获取的。
     * 工厂模式返回的实例可以不是新创建的，返回由工厂创建好的实例也是可以的。
     * 
     * 用了工厂方法模式，你替换生成键盘的工厂方法，就可以把键盘从苹果换到微软。
     * 但是用了抽象工厂模式，你只要换家工厂，就可以同时替换鼠标和键盘一套。
     * 如果你要的产品有几十个，当然用抽象工厂模式一次替换全部最方便
     * 
     * 所以说抽象工厂就像工厂，而工厂方法则像是工厂的一种产品生产线。
     * 抽象工厂”模式依赖于“工厂方法”模式的。
     * 因此，抽象工厂强调的是前面的动词“抽象”，也就是说，你将工厂方法模式中的工厂方法抽象出来的那个"动作或设计"就是“抽象工程”模式了。
     * 
     * 简单工厂 ： 用来生产同一等级结构中的任意产品。（对于增加新的产品，无能为力）
     * 工厂方法 ：用来生产同一等级结构中的固定产品。（支持增加任意产品）  
     * 抽象工厂 ：用来生产不同产品族的全部产品。（对于增加新的产品，无能为力；支持增加产品族）   
     *    1.如果一个后花园只种蔬菜类,那么就用简单工厂就可以了.
     *    2.如果后花园蔬菜品种繁多.得用工厂方法才可以,把共有的东西抽象出来.
     *    3.如果要扩大后花园的规模,比如一个在北方,一个在南方,这样工厂方法就无法实现了,就应当用抽象工厂,把各种各样的植物,又组成一个后花园.
     * 
     * 工厂方法模式：一个抽象产品类，可以派生出多个具体产品类。 
     *              一个抽象工厂类，可以派生出多个具体工厂类。 
     *              每个具体工厂类只能创建一个具体产品类的实例。 
     *              
     * 抽象工厂模式：多个抽象产品类，每个抽象产品类可以派生出多个具体产品类。 
     *              一个抽象工厂类，可以派生出多个具体工厂类。 
     *              每个具体工厂类可以创建多个具体产品类的实例。 
     * 
     * 
     * 简单工厂：是一个工厂只生产一类的产品,面对的是具体的类。
     * 工厂方法：是可以生产不同的产品,把公共的方法抽象出来,然后进行创建各种各样的产品。
     * 抽象工厂：把几种产品划出共同的东西,把相互依赖的对象抽象出来,只要实现这些接口就可以得到不同的产品。
     * 
     * 
     * 此模式的核心精神是封装类中不变的部分，提取其中个性化善变的部分为独立类，通过依赖注入以达到解耦、复用和方便后期维护拓展的目的。
     * 它的核心结构有四个角色，分别是抽象工厂；具体工厂；抽象产品；具体产品
     * 工厂方法模式是定义一个创建产品对象的工厂接口，工厂接口本身不去创建对象，而是交给其子类或者是其实现类去创建，将实际创建工作推迟到子类中进行，
     * 工厂方法模式遵循了开放-封闭原则，针对扩展是开放的，针对修改是封闭的。其实它是将判断工作转移到了客户端调用之处，这样保证了工厂体系的完整性。
     * 
     * */

   #endregion


    public class 测试类
    {
        public static void 运行()
        {
            交通工具 tool = new 奔驰();
            性能考察 ability = tool.考察();
            ability.性能();

            Console.ReadKey();
        }
    }

    //----------------------------------------------------------------------------------------

    //抽象产品
    public interface 性能考察
    {
        void 性能();
    }

    //具体产品
    public class 宝马性能 : 性能考察
    {
        public void 性能()
        {
            Console.WriteLine("宝马车性能不赖");
        }
    }

    //具体产品
    public class 奔驰性能 : 性能考察
    {
        public void 性能()
        {
            Console.WriteLine("奔驰车性能杠杠的");
        }
    }


    //抽象工厂
    public abstract class 交通工具
    {
        public abstract 性能考察 考察();   
    }

    //具体工厂
    public class 宝马 : 交通工具
    {
        public override 性能考察 考察()
        {
            return new 宝马性能();
        }
    }
    //具体工厂
    public class 奔驰 : 交通工具
    {
        public override 性能考察 考察()
        {
            return new 奔驰性能();
        }
    }


}
