<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01//EN" "http://www.w3.org/TR/html4/strict.dtd">
<html lang="en">
<head>
	<meta http-equiv="Content-Type" content="text/html;charset=UTF-8">
	<title>结构型模式</title>
</head>
<body>
	<a href="#hh2"><div style="border: 1px solid; width: 40px;margin-left: 80%;margin-top:50%;position: fixed;">
		<b>返回顶部</b>
	</div></a>
	<h2 id="hh2"><a href="创建性模式.html" style="font-size:10px">上一个</a>&nbsp;&nbsp;结构型模式&nbsp;&nbsp;<a href="行为型模式.html" style="font-size:10px">下一个</a></h2>
<pre>
  结构型模式，顾名思义讨论的是类和对象的结构，主要用处理类或对象的组合。
  它包括两种类型：
  一、类结构型模式，指的是采用继承机制来组合接口或实现；
  二、对象结构型模式，指的是通过组合对象的方式来实现新的功能。
  包括：<a href="#a">适配器模式</a>、<a href="#b">桥接模式</a>、<a href="#c">装饰者模式</a>、<a href="#d">组合模式</a>、<a href="#e">外观模式</a>、
  	    <a href="#f">享元模式</a>、<a href="#g">代理模式</a>
</pre>
<div>
	<ul>
		<li>适配器模式注重转换接口，将不吻合的接口适配对接</li>
		<li>桥接模式注重分离接口与其实现，支持多维度变化</li>
		<li>组合模式注重统一接口，将“一对多”的关系转换为“一对一”的关系</li>
		<li>装饰者模式注重稳定接口，在此前提下为对象扩展功能</li>
		<li>外观模式注重简化接口，简化组件系统与外部客户程序的依赖关系</li>
		<li>享元模式注重保留接口，在内部使用共享技术对对象存储进行优化</li>
		<li>代理模式注重假借接口，增加间接层来实现灵活控制</li>
	</ul>
</div>
<div>
	<h3 id="a">适配器模式</h3>
	<pre>
  介绍：
    把一个类的接口变换成客户端所期待的另一种接口，从而使原本接口不匹配而无法一起工作的两个类能够在一起工作。
    适配器模式有类的适配器和对象的适配器两种形式
  备注：
    目标角色是接口，源角色是抽象类。需要根据适配器把，源角色转换为目标角色。适配器类继承抽象类、源角色接口。并返回源角色
    目标角色是方法，源角色是方法。适配器类继承目标角色，内部返回源角色
  常用场景：需要使用一个类的功能，但是该类的接口不符合使用场合要求的接口，可使用定制适配器，又或者是有一个接口定义的行为过多，则可以定义一个缺省适配器，让子类选择性的覆盖适配器的方法。
  选择关键点：定制适配器的选择关键点在于是否有更加优良的替代方案，缺省适配器的选择关键点在于接口中的方法是否可以不全部提供，且都有缺省方案。
  逆鳞：-
	</pre>
</div>
<div>
	<h3 id="b">桥接模式</h3>
	<pre>
  介绍：
    抽象化和实现部分在一起，桥接模式的目的就是使两者分离，根据面向对象的封装变化的原则，我们可以把实现部分的变化（也就是遥控器功能的变化）封装到另外一个类中
  备注：
    重写抽象类中某一个方法，派生类继承抽象类，在派生类重写该方法，实例化的时候，实例派生类
  常用场景：一个对象有多个维度的变化，需要将这些维度抽离出来，让且独立变化。
  选择关键点：是否可以将对象拆分成多个不相关的维度。
  逆鳞：-
	</pre>
</div>
<div>
	<h3 id="c">装饰器模式</h3>
	<pre>
  介绍：
    装饰者模式来动态地给一个对象添加额外的职责。
    装饰者模式以对客户透明的方式动态地给一个对象附加上更多的责任，装饰者模式相比生成子类可以更灵活地增加功能
  备注：
    抽象类派生一个装饰类，装饰类派生不同的方法。如果有需要就重写方法，没有需要就base执行。调用的时候，装饰类初始化装饰派生类
  常用场景：一个类需要动态的添加功能，且这些功能可以相互叠加
  选择关键点：添加的功能是否要动态组装
  逆鳞：-
	</pre>
</div>
<div>
	<h3 id="d">组合模式</h3>
	<pre>
  介绍：
    组合模式允许你将对象组合成树形结构来表现”部分-整体“的层次结构，使得客户以一致的方式处理单个对象以及对象的组合
    组合模式实现的最关键的地方是——简单对象和复合对象必须实现相同的接口。这就是组合模式能够将组合对象和简单对象进行一致处理的原因。
  备注：
    分为透明模式和安全模式，透明模式所有都遵循一个接口，安全模式会在派生类添加额外方法实现。
  常用场景：当有一个结构可以组合成树形结构，且需要向客户端提供一致的操作接口，使得客户端操作忽略简单元素与复杂元素
  选择关键点：对外提供一致操作接口的结构是否可以转化为树形结构。
  逆鳞：结构不稳定或结构中的节点有递归关系。
	</pre>
</div>
<div>
	<h3 id="e">外观模式</h3>
	<pre>
  介绍：
    外观模式提供了一个统一接口，用来访问子系统的一群接口。外观定义了一个高级接口，让子系统更容易接受。
    外观模式的实现核心主要是——由外观类去保存各个子系统的引用，实现由一个统一的外观类去包装多个子系统类，然而客户端只需要引用这个外观类，然后由外观类来调用各个子系统中的方法
  备注：
    就是把多种方法，组合成一个任务链，访问只需要访问任务链即可。任务链内部自动添加其他任务
  常用场景：一个子系统需要对外提供服务
  选择关键点：子系统对外提供服务是否需要依赖很多的类
  逆鳞：子系统对外提供的服务的变化或子系统本身的不稳定
	</pre>
</div>
<div>
	<h3 id="f">享元模式</h3>
	<pre>
  介绍：
    运用共享技术有效地支持大量细粒度的对象。享元模式可以避免大量相似类的开销，
    在软件开发中如果需要生成大量细粒度的类实例来表示数据，如果这些实例除了几个参数外基本上都是相同的，这时候就可以使用享元模式来大幅度减少需要实例化类的数量。
  备注：
    如果对象只有某些字段不同，可以使用。将不同的字段存储，然后 返回同一个对象。
  常用场景：一些状态相同的对象被大量的重复使用
  选择关键点：被共享的对象是否可以将外部状态提取出来
  逆鳞：没有将外部状态提取完全
	</pre>
</div>
<div>
	<h3 id="g">代理模式</h3>
	<pre>
  介绍：
    就是给某一个对象提供一个代理，并由代理对象控制对原对象的引用。
    在一些情况下，一个客户不想或者不能直接引用一个对象，而代理对象可以在客户端和目标对象之间起到中介的作用。例如电脑桌面的快捷方式就是一个代理对象，快捷方式是它所引用的程序的一个代理。
  备注：
    把多种操作封装成一个地方，然后供客户端调用
  常用场景：需要修改或屏蔽某一个或若干个类的部分功能，复用另外一部分功能，可使用静态代理，若是需要拦截一批类中的某些方法，在方法的前后插入一些一致的操作，假设这些类有一致的接口，可使用动态代理。
  选择关键点：静态代理选择的关键点是是否需要复用被代理的部分功能，动态代理选择的关键点在于能否在将被代理的这一批类当中，找出相同的切入点。
  逆鳞：切入点的不稳定
	</pre>
</div>
</body>
</html>